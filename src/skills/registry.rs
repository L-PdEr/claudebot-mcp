//! Skill Registry
//!
//! Manages installed skills, persistence, and execution.

use super::types::*;
use super::generator::GeneratedSkill;
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

/// Installed skill with runtime metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstalledSkill {
    /// Skill definition
    pub definition: SkillDefinition,
    /// Installation timestamp
    pub installed_at: i64,
    /// Last used timestamp
    pub last_used: Option<i64>,
    /// Usage count
    pub usage_count: u64,
    /// Success count
    pub success_count: u64,
    /// Is this skill enabled?
    pub enabled: bool,
    /// Source (generated, imported, builtin)
    pub source: SkillSource,
    /// File path if persisted
    pub file_path: Option<PathBuf>,
}

impl InstalledSkill {
    /// Create from a generated skill
    pub fn from_generated(skill: GeneratedSkill, source: SkillSource) -> Self {
        Self {
            definition: skill.definition,
            installed_at: chrono::Utc::now().timestamp(),
            last_used: None,
            usage_count: 0,
            success_count: 0,
            enabled: true,
            source,
            file_path: None,
        }
    }

    /// Record usage
    pub fn record_usage(&mut self, success: bool) {
        self.last_used = Some(chrono::Utc::now().timestamp());
        self.usage_count += 1;
        if success {
            self.success_count += 1;
        }
    }

    /// Get success rate
    pub fn success_rate(&self) -> f64 {
        if self.usage_count == 0 {
            1.0
        } else {
            self.success_count as f64 / self.usage_count as f64
        }
    }
}

/// Skill source
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SkillSource {
    /// Generated by the agent
    Generated,
    /// Imported from file
    Imported(PathBuf),
    /// Downloaded from hub
    Hub(String),
    /// Built-in skill
    Builtin,
}

/// Skill registry
pub struct SkillRegistry {
    /// Installed skills by name
    skills: RwLock<HashMap<String, InstalledSkill>>,
    /// Skills directory
    skills_dir: PathBuf,
    /// HTTP client for skill execution
    client: reqwest::Client,
}

impl SkillRegistry {
    /// Create new registry with skills directory
    pub fn new(skills_dir: PathBuf) -> Self {
        Self {
            skills: RwLock::new(HashMap::new()),
            skills_dir,
            client: reqwest::Client::new(),
        }
    }

    /// Create from default location (~/.claudebot/skills)
    pub fn default_location() -> Self {
        let skills_dir = dirs::home_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join(".claudebot")
            .join("skills");

        // Ensure directory exists
        std::fs::create_dir_all(&skills_dir).ok();

        Self::new(skills_dir)
    }

    /// Load all skills from disk
    pub async fn load_all(&self) -> Result<usize> {
        let mut count = 0;

        if !self.skills_dir.exists() {
            return Ok(0);
        }

        let entries = std::fs::read_dir(&self.skills_dir)
            .context("Failed to read skills directory")?;

        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().map(|e| e == "toml").unwrap_or(false) {
                match self.load_from_file(&path).await {
                    Ok(_) => count += 1,
                    Err(e) => warn!("Failed to load skill from {:?}: {}", path, e),
                }
            }
        }

        info!("Loaded {} skills from disk", count);
        Ok(count)
    }

    /// Load a skill from TOML file
    pub async fn load_from_file(&self, path: &Path) -> Result<String> {
        let content = tokio::fs::read_to_string(path)
            .await
            .context("Failed to read skill file")?;

        let definition: SkillDefinition = toml::from_str(&content)
            .context("Failed to parse skill TOML")?;

        definition.validate()?;

        let skill = InstalledSkill {
            definition: definition.clone(),
            installed_at: chrono::Utc::now().timestamp(),
            last_used: None,
            usage_count: 0,
            success_count: 0,
            enabled: true,
            source: SkillSource::Imported(path.to_path_buf()),
            file_path: Some(path.to_path_buf()),
        };

        let name = skill.definition.skill.name.clone();
        let mut skills = self.skills.write().await;
        skills.insert(name.clone(), skill);

        info!("Loaded skill '{}' from {:?}", name, path);
        Ok(name)
    }

    /// Install a generated skill
    pub async fn install(&self, skill: GeneratedSkill) -> Result<String> {
        skill.definition.validate()?;

        let name = skill.definition.skill.name.clone();
        let mut installed = InstalledSkill::from_generated(skill, SkillSource::Generated);

        // Persist to disk
        let file_path = self.skills_dir.join(format!("{}.toml", name));
        let toml_content = toml::to_string_pretty(&installed.definition)
            .context("Failed to serialize skill")?;

        tokio::fs::create_dir_all(&self.skills_dir).await.ok();
        tokio::fs::write(&file_path, &toml_content)
            .await
            .context("Failed to write skill file")?;

        installed.file_path = Some(file_path.clone());

        let mut skills = self.skills.write().await;
        skills.insert(name.clone(), installed);

        info!("Installed skill '{}' to {:?}", name, file_path);
        Ok(name)
    }

    /// Uninstall a skill
    pub async fn uninstall(&self, name: &str) -> Result<()> {
        let mut skills = self.skills.write().await;

        if let Some(skill) = skills.remove(name) {
            // Delete file if exists
            if let Some(path) = skill.file_path {
                tokio::fs::remove_file(&path).await.ok();
            }
            info!("Uninstalled skill '{}'", name);
            Ok(())
        } else {
            anyhow::bail!("Skill '{}' not found", name)
        }
    }

    /// Get a skill by name
    pub async fn get(&self, name: &str) -> Option<InstalledSkill> {
        let skills = self.skills.read().await;
        skills.get(name).cloned()
    }

    /// List all installed skills
    pub async fn list(&self) -> Vec<InstalledSkill> {
        let skills = self.skills.read().await;
        skills.values().cloned().collect()
    }

    /// Search skills by keyword
    pub async fn search(&self, query: &str) -> Vec<InstalledSkill> {
        let lower_query = query.to_lowercase();
        let skills = self.skills.read().await;

        skills
            .values()
            .filter(|s| {
                s.definition.skill.name.to_lowercase().contains(&lower_query)
                    || s.definition.skill.description.to_lowercase().contains(&lower_query)
                    || s.definition.skill.tags.iter().any(|t| t.to_lowercase().contains(&lower_query))
            })
            .cloned()
            .collect()
    }

    /// Execute a skill with parameters
    pub async fn execute(
        &self,
        name: &str,
        params: serde_json::Value,
    ) -> Result<SkillResult> {
        // Get skill (and update usage later)
        let skill = {
            let skills = self.skills.read().await;
            skills.get(name).cloned()
        };

        let skill = skill.ok_or_else(|| anyhow::anyhow!("Skill '{}' not found", name))?;

        if !skill.enabled {
            anyhow::bail!("Skill '{}' is disabled", name);
        }

        let start = std::time::Instant::now();
        let result = self.execute_internal(&skill.definition, params).await;
        let duration_ms = start.elapsed().as_millis() as u64;

        // Update usage stats
        {
            let mut skills = self.skills.write().await;
            if let Some(s) = skills.get_mut(name) {
                s.record_usage(result.is_ok());
            }
        }

        match result {
            Ok(output) => Ok(SkillResult {
                skill_name: name.to_string(),
                success: true,
                output,
                error: None,
                duration_ms,
            }),
            Err(e) => Ok(SkillResult {
                skill_name: name.to_string(),
                success: false,
                output: String::new(),
                error: Some(e.to_string()),
                duration_ms,
            }),
        }
    }

    /// Internal execution logic
    async fn execute_internal(
        &self,
        definition: &SkillDefinition,
        params: serde_json::Value,
    ) -> Result<String> {
        match &definition.execution.exec_type {
            ExecutionType::Http => self.execute_http(&definition.execution, &params).await,
            ExecutionType::Shell => self.execute_shell(&definition.execution, &params).await,
            ExecutionType::Script => self.execute_script(&definition.execution, &params).await,
            ExecutionType::Claude => self.execute_claude(&definition.execution, &params).await,
        }
    }

    /// Execute HTTP skill
    async fn execute_http(
        &self,
        config: &ExecutionConfig,
        params: &serde_json::Value,
    ) -> Result<String> {
        let endpoint = config.endpoint.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Missing endpoint"))?;
        let method = config.method.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Missing method"))?;

        // Interpolate parameters in endpoint
        let url = interpolate_template(endpoint, params);

        let mut request = match method.to_uppercase().as_str() {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url).json(params),
            "PUT" => self.client.put(&url).json(params),
            "DELETE" => self.client.delete(&url),
            _ => anyhow::bail!("Unsupported HTTP method: {}", method),
        };

        // Add headers
        for (key, value) in &config.headers {
            let interpolated = interpolate_template(value, params);
            request = request.header(key, interpolated);
        }

        let response = request
            .timeout(std::time::Duration::from_secs(config.timeout_secs))
            .send()
            .await
            .context("HTTP request failed")?;

        let status = response.status();
        let body = response.text().await.context("Failed to read response body")?;

        if status.is_success() {
            Ok(body)
        } else {
            anyhow::bail!("HTTP error {}: {}", status, body)
        }
    }

    /// Execute shell skill
    async fn execute_shell(
        &self,
        config: &ExecutionConfig,
        params: &serde_json::Value,
    ) -> Result<String> {
        let command = config.command.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Missing command"))?;

        // Interpolate parameters
        let interpolated = interpolate_template(command, params);

        let output = tokio::process::Command::new("sh")
            .arg("-c")
            .arg(&interpolated)
            .output()
            .await
            .context("Failed to execute command")?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("Command failed: {}", stderr)
        }
    }

    /// Execute script skill
    async fn execute_script(
        &self,
        config: &ExecutionConfig,
        params: &serde_json::Value,
    ) -> Result<String> {
        let script = config.script.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Missing script"))?;
        let language = config.language.as_deref().unwrap_or("python");

        // Interpolate parameters in script
        let interpolated = interpolate_template(script, params);

        let (cmd, args): (&str, Vec<&str>) = match language {
            "python" | "python3" => ("python3", vec!["-c", &interpolated]),
            "javascript" | "node" => ("node", vec!["-e", &interpolated]),
            "ruby" => ("ruby", vec!["-e", &interpolated]),
            "bash" | "sh" => ("bash", vec!["-c", &interpolated]),
            _ => anyhow::bail!("Unsupported script language: {}", language),
        };

        let output = tokio::process::Command::new(cmd)
            .args(&args)
            .output()
            .await
            .context("Failed to execute script")?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("Script failed: {}", stderr)
        }
    }

    /// Execute Claude-powered skill
    async fn execute_claude(
        &self,
        config: &ExecutionConfig,
        params: &serde_json::Value,
    ) -> Result<String> {
        let prompt_template = config.prompt.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Missing prompt"))?;

        // Interpolate parameters in prompt
        let prompt = interpolate_template(prompt_template, params);

        // Call Claude via the existing API
        let api_key = std::env::var("ANTHROPIC_API_KEY")
            .context("ANTHROPIC_API_KEY not set")?;

        let response = self
            .client
            .post("https://api.anthropic.com/v1/messages")
            .header("x-api-key", &api_key)
            .header("anthropic-version", "2023-06-01")
            .header("content-type", "application/json")
            .json(&serde_json::json!({
                "model": "claude-sonnet-4-20250514",
                "max_tokens": 4096,
                "messages": [
                    {"role": "user", "content": prompt}
                ]
            }))
            .timeout(std::time::Duration::from_secs(config.timeout_secs))
            .send()
            .await
            .context("Claude API request failed")?;

        if response.status().is_success() {
            let body: serde_json::Value = response.json().await?;
            if let Some(text) = body["content"][0]["text"].as_str() {
                Ok(text.to_string())
            } else {
                anyhow::bail!("Unexpected Claude response format")
            }
        } else {
            let status = response.status();
            let error = response.text().await.unwrap_or_default();
            anyhow::bail!("Claude API error {}: {}", status, error)
        }
    }

    /// Enable a skill
    pub async fn enable(&self, name: &str) -> Result<()> {
        let mut skills = self.skills.write().await;
        if let Some(skill) = skills.get_mut(name) {
            skill.enabled = true;
            Ok(())
        } else {
            anyhow::bail!("Skill '{}' not found", name)
        }
    }

    /// Disable a skill
    pub async fn disable(&self, name: &str) -> Result<()> {
        let mut skills = self.skills.write().await;
        if let Some(skill) = skills.get_mut(name) {
            skill.enabled = false;
            Ok(())
        } else {
            anyhow::bail!("Skill '{}' not found", name)
        }
    }

    /// Get statistics
    pub async fn stats(&self) -> SkillStats {
        let skills = self.skills.read().await;

        let total = skills.len();
        let enabled = skills.values().filter(|s| s.enabled).count();
        let total_usage: u64 = skills.values().map(|s| s.usage_count).sum();
        let avg_success_rate = if total > 0 {
            skills.values().map(|s| s.success_rate()).sum::<f64>() / total as f64
        } else {
            1.0
        };

        SkillStats {
            total,
            enabled,
            disabled: total - enabled,
            total_usage,
            avg_success_rate,
        }
    }
}

/// Skill execution result
#[derive(Debug, Clone, Serialize)]
pub struct SkillResult {
    pub skill_name: String,
    pub success: bool,
    pub output: String,
    pub error: Option<String>,
    pub duration_ms: u64,
}

/// Registry statistics
#[derive(Debug, Clone, Serialize)]
pub struct SkillStats {
    pub total: usize,
    pub enabled: usize,
    pub disabled: usize,
    pub total_usage: u64,
    pub avg_success_rate: f64,
}

/// Interpolate template with parameters
fn interpolate_template(template: &str, params: &serde_json::Value) -> String {
    let mut result = template.to_string();

    if let Some(obj) = params.as_object() {
        for (key, value) in obj {
            let placeholder = format!("{{{{{}}}}}", key);
            let replacement = match value {
                serde_json::Value::String(s) => s.clone(),
                _ => value.to_string(),
            };
            result = result.replace(&placeholder, &replacement);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interpolate_template() {
        let template = "Hello, {{name}}! You are {{age}} years old.";
        let params = serde_json::json!({
            "name": "Alice",
            "age": 30
        });

        let result = interpolate_template(template, &params);
        assert_eq!(result, "Hello, Alice! You are 30 years old.");
    }

    #[test]
    fn test_skill_success_rate() {
        let mut skill = InstalledSkill {
            definition: SkillDefinition::new(
                "test",
                "Test skill",
                ExecutionConfig::shell("echo test"),
            ),
            installed_at: 0,
            last_used: None,
            usage_count: 0,
            success_count: 0,
            enabled: true,
            source: SkillSource::Builtin,
            file_path: None,
        };

        // Initial success rate is 1.0 (no data)
        assert_eq!(skill.success_rate(), 1.0);

        // Record some usage
        skill.record_usage(true);
        skill.record_usage(true);
        skill.record_usage(false);

        assert_eq!(skill.usage_count, 3);
        assert_eq!(skill.success_count, 2);
        assert!((skill.success_rate() - 0.666).abs() < 0.01);
    }
}
